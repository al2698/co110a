# nand2tertris加速

1. 多層次快取
	- 因為dram比CPU慢，指令集必須向快取看齊
	- 暫存器不能太大，需要更多暫存器中的空間幫忙定位，如：32bit 需要 5bit ；1024 需要 10bit
2. 管線機制 (pipeline)
	- 用暫存器達到，讓每個部分可以同時做事
   
3. 多核心 + Hyper-Threading
	- 每個核心都有自己的ALU(1core 1ALU)、快取、控制電路和暫存器，最後連接到MemorySystem
   
4. 螢幕繪製交給顯卡(GPU)
	- GPU裡面有很多ALU(1core nALU)，在繪圖運算上比CPU快很多
   
5. 利用直式提升HackCPU(沒有乘法)乘法計算


```
  5         0101
* 7         0111
=================
             101
            101
           101
+         000
=================
 35       100011
```
- 移位：自己加自己


## 補充  IEEE 754 對齊

```
S(Significand): 這個值1代表為正數、0代表負數
e(exponent):  取2的n次方加上127，就是e的值(-127 < e < +128)， e從127開始加就是為了表示很小的數
m(mantissa): 紀錄小數點後的數字(由左到右) 

|S|  e  |        m         |

|1|  8  |       23         | bit  單精度float

|1|  11 |       52         | bit  雙精度float

運算表示法 --> -1^S * 2^e * m (這邊e沒經過處裡，只是表示處裡過的最後結果)
```
浮點數乘法：

```
設：
d1 = -1^S1 * 2^e1 * m1
d2 = -1^S2 * 2^e2 * m2

乘法:
d1 * d2 = -1 ^ (S1+S2) * 2 ^ (e1+e2) + m1*m2

|(S1+S2)|  (e1+e2)  |        m1*m2         | --> 得到的浮點數
```
浮點數加法：

```

d1: |S|  e  |        m1         |  
      |  3  | 

d2: |S|  e       |        m2         |
      |  6       | 
      
兩個運算元的階碼需相等(對齊小數點)，所以d1 要 * 2 ^ 3，相對 m 就會右移 3 位

EX: 10.5 = 1.0101 * 2^3 = 0.010101 * 2^6
從原本的  0 10000010 01010000000000000000000
變成     0 10000013 00101010000000000000000

規則： 小階向大階看齊，階小的數的尾數右移，右移位數等於兩個階碼差的絕對值。
d1 + d2 = -1 ^ (S) * 2 ^ (e) + m1+m2

|S|  e  |        m1+m2         | --> 得到的浮點數
```






# RISC-V能否複製Linux的成功？


## 簡介
今年是Linux核心發佈三十一週年；利用公開免費發佈的Linux，開放原始碼催生了數百項專案。Linux的成功模式是否能複製到開源硬體？RISC-V指令集架構(ISA)是否能像Linux核心作為開源軟體的基礎一樣，成為開源硬體發展的基石呢？以下會從三個需要克服的問題，分別是：品質與生態系統、社群支援、晶圓製程技術



## 品質與生態系統


## 社群支援


## 晶圓製程技術

