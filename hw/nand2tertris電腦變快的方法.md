來源申明：

1. nand2tertris加速：12/9 到教室上課表記
   - pipline 參考網站：[wikipedia](https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E7%AE%A1%E7%B7%9A%E5%8C%96)
   - Hyper-Threading 參考網站：[中文百科](https://www.newton.com.tw/wiki/Hyper-Threading)、[intel](https://www.intel.com.tw/content/www/tw/zh/gaming/resources/hyper-threading.html)
   - 浮點數計算 參考網站：[osc_vnopwmym筆記](https://www.gushiciku.cn/pl/pFUb/zh-tw)
2. RISC-V能否複製Linux的成功：[參考網站](https://www.eettaiwan.com/20210406nt31-can-open-source-hardware-emulate-linux/)

# nand2tertris加速

1. 多層次快取
	- 因為dram比CPU慢，指令集必須向快取看齊
	- 暫存器不能太大，需要更多暫存器中的空間幫忙定位，如：32bit 需要 5bit ；1024 需要 10bit
	
2. 管線機制 (pipeline)
	- 目的是讓每一個stage的硬體在每一個cycle都盡量去運作，避免空窗期。
   
   ![](https://upload.wikimedia.org/wikipedia/commons/6/67/5_Stage_Pipeline.svg)
   
3. 多核心 + Hyper-Threading
	- 超執行緒技術是一種硬體創新，能讓 **每個** 核心執行多執行緒。執行緒愈多，可以平行處理的工作愈多。
   - 超執行緒技術就是利用特殊的硬體指令，把一個物理核心模擬成兩個邏輯核心，讓單個處理器都能使用執行緒級並行計算。
   
4. 螢幕繪製交給顯卡(GPU)
	-  “硬解”是硬體解碼的簡稱。簡單而言，硬體解碼就是通過顯示卡的視訊加速功能對高清視訊進行解碼。因為GPU 這種處理器是由許多更小也更專業的核心所組成，解碼工作交由顯示卡辦理來減輕CPU的負擔。
   
5. 利用直式提升HackCPU(沒有乘法)乘法計算


```
  5         0101
* 7         0111
=================
             101
            101
           101
+         000
=================
 35       100011
```
- 移位：自己加自己


## 補充  IEEE 754 對齊

```
S(Significand): 這個值1代表為正數、0代表負數
e(exponent):  取2的n次方加上127，就是e的值(-127 < e < +128)， e從127開始加就是為了表示很小的數
m(mantissa): 紀錄小數點後的數字(由左到右) 

|S|  e  |        m         |

|1|  8  |       23         | bit  單精度float

|1|  11 |       52         | bit  雙精度float

運算表示法 --> -1^S * 2^e * m (這邊e沒經過處裡，只是表示處裡過的最後結果)
```
浮點數乘法：

```
設：
d1 = -1^S1 * 2^e1 * m1
d2 = -1^S2 * 2^e2 * m2

乘法:
d1 * d2 = -1 ^ (S1+S2) * 2 ^ (e1+e2) + m1*m2

|(S1+S2)|  (e1+e2)  |        m1*m2         | --> 得到的浮點數
```
浮點數加法：

```

d1: |S|  e  |        m1         |  
      |  3  | 

d2: |S|  e       |        m2         |
      |  6       | 
      
兩個運算元的階碼需相等(對齊小數點)，所以d1 要 * 2 ^ 3，相對 m 就會右移 3 位

EX: 10.5 = 1.0101 * 2^3 = 0.010101 * 2^6
從原本的  0 10000010 01010000000000000000000
變成新的  0 10000101 00101010000000000000000

規則： 小階向大階看齊，階小的數的尾數右移，右移位數等於兩個階碼差的絕對值。
d1 + d2 = -1 ^ (S) * 2 ^ (e) + m1+m2

|S|  e  |        m1+m2         | --> 得到的浮點數
```






# RISC-V能否複製Linux的成功？


## 簡介
今年是Linux核心發佈三十一週年；利用公開免費發佈的Linux，開放原始碼催生了數百項專案。Linux的成功模式是否能複製到開源硬體？RISC-V指令集架構(ISA)是否能像Linux核心作為開源軟體的基礎一樣，成為開源硬體發展的基石呢？以下會從三個需要克服的問題，分別是：品質與生態系統、社群支援、晶圓製程技術



## 品質與生態系統

OpenHW Group總裁兼執行長Rick O’Connor認為，RISC-V相當於Linux核心，他在接受採訪時說：「RISC-V ISA一開始就像核心之於Linux一樣，其結果是催生其他開源軟體專案和計畫如雨後春筍般湧現。當然，如果說Linux核心為20年前的軟體播種，那麼RISC-V ISA就是硬體的種子。」

然而，採用開源硬體仍然存在障礙。「障礙之一就是品質問題。」O’Connor補充道：「例如，如果你在一個晶片或SoC產量較高的公司工作，肯定不會把寶押在這個從網路下載來的IP模組上，然後直接走進老闆辦公室說：『我們準備好使用這個大學開發的酷炫核心了，它應該可以導入我們的量產SoC中。』」

因此，OpenHW Group倡議開放的驗證流程。O’Connor說：「人們可以查看生態系統達到的品質並使用所得到的結果——如果完全自行開發，應該就能獲得高產量SoC公司所期望的結果。」



## 社群支援

隨著開源從軟體擴展到硬體，越來越需要社群或合作夥伴生態系統的參與。Oshana說：「任何一個開放的社群都需要培養、照顧與供給。隨便扔點東西進Git就稱其為『開放』，這樣註定會失敗。它需要一個社群。」

「如果不是經過社群的努力，建構了核心、開發板、軟體和參考平台，OpenHW Group的核心無法取得成功。」他補充說：「OpenHW Group正利用最佳實踐而使得這一硬體技術成功。」

Oshana認為，其關鍵就在於如何利用最佳實踐並「持續投資實際工程，以保持硬體開發的成功。」

同時，開源工具也在不斷發展中。「我們需要一套可靠的硬體工具來支援，」Oshana指出。和其他人一樣，他也認為真正衡量一個開放社群的標準是參與度。例如，一旦發佈一種實施方案，關鍵指標就在於用戶社群如何管理更改需求、修復錯誤等。Oshana說：「這相當於Linux的上游。維護者的角色必須明確。」




## 晶圓製程技術

開源硬體和軟體的主要區別在於整個堆疊的複雜性。O’Connor說：「看看當今生產的絕大部份晶片，其中有超過95%採用Verilog工具流程並在相應的商業驗證基礎設施中生產和驗證。因此，如果我們想讓別人使用這些核心，就要讓它們輕鬆融入到這種商業工具流程中。」

硬體的實體特性仍然使軟體開發人員面臨前所未有的挑戰。O’Connor指出：「在半導體晶圓廠中，從幾何層面的物理特性來看，其秘訣就在於晶圓製程。」他提到了採用較大節點製程設計中那些鼓舞人心的成果。

他解釋說：「當你有了晶圓製程技術、最重要的工具庫、生產GDSII的CAD工具實體層以及光罩技術本身；接著還需要生產光罩的設備、驗證設計的模擬和驗證軟體與工具、用於擷取和合成設計的合成工具，以及用於這些設計的IP。」



## 下一輪運算革命？

幾乎就在二十年前，程式設計人員並不看好Linux，認為這只是一項利基技術，推測其發展有限。如今，我們看到硬體社群再現了二十年前Linux的發展過程，新創公司基於RISC-V開放標準來設計處理器，創投業者則在仔細審查這些晶片新貴。

像Nvidia和WD這樣的巨擘也在開始大量採用RISC-V。

RISC-V最初只是一項研究專案，經過不斷發展，現在已經發展成為處理器設計的開放標準了。正如Swift所指出的，RISC-V並不同於過去指令集之間的派系之爭，而是展現其創新能力和選擇自由。

隨著RISC-V的迅速發展，圍繞RISC-V處理器設計的基礎設施和軟體生態也彙集在一起了。RISC-V開放標準穩健發展且充滿活力，象徵著開源硬體的未來前景，或許也正引領著下一場運算革命。
